<section class="webgl-demo" data-webgl-cube-demo>
  <div class="webgl-stage" data-webgl-stage aria-label="WebGL rotating cubes demo"></div>
  <p class="webgl-status" data-webgl-status hidden></p>
</section>

<script>
  import * as THREE from 'three';

  const initDemo = root => {
    if (!(root instanceof HTMLElement) || root.dataset.webglReady === '1') return;
    root.dataset.webglReady = '1';

    const stage = root.querySelector('[data-webgl-stage]');
    const status = root.querySelector('[data-webgl-status]');
    if (!(stage instanceof HTMLElement)) return;

    const showStatus = message => {
      if (status instanceof HTMLElement) {
        status.textContent = message;
        status.hidden = false;
      }
      root.classList.add('is-fallback');
    };

    let renderer;
    try {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
        powerPreference: 'high-performance',
      });
    } catch {
      showStatus('WebGL unavailable on this browser/device.');
      return;
    }

    const gl = renderer.getContext();
    if (!gl) {
      showStatus('WebGL context could not be created on this browser/device.');
      renderer.dispose();
      return;
    }

    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.domElement.style.display = 'block';
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    stage.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#050913');

    const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 100);
    camera.position.set(0.5, 0.35, 5.2);

    const cubeA = new THREE.Mesh(
      new THREE.BoxGeometry(1.08, 1.08, 1.08),
      new THREE.MeshStandardMaterial({ color: 0x5ea9ff, roughness: 0.26, metalness: 0.24 }),
    );
    cubeA.position.set(-0.6, 0.02, 0.15);

    const cubeB = new THREE.Mesh(
      new THREE.BoxGeometry(0.9, 0.9, 0.9),
      new THREE.MeshStandardMaterial({ color: 0x42cf74, roughness: 0.3, metalness: 0.18 }),
    );
    cubeB.position.set(1.35, 0.72, -1.3);

    scene.add(cubeA);
    scene.add(cubeB);
    scene.add(new THREE.AmbientLight(0xffffff, 0.34));

    const keyLight = new THREE.DirectionalLight(0xffffff, 0.95);
    keyLight.position.set(3, 2.7, 4.2);
    scene.add(keyLight);

    const fillLight = new THREE.PointLight(0x5ea9ff, 0.75, 14);
    fillLight.position.set(-3.2, -0.8, 2.2);
    scene.add(fillLight);

    let rafId = 0;
    let observer = null;

    const resize = () => {
      const bounds = stage.getBoundingClientRect();
      const width = Math.max(280, Math.round(bounds.width || stage.clientWidth || root.clientWidth || 280));
      const height = Math.max(220, Math.min(520, Math.round(width * 0.58)));

      stage.style.height = `${height}px`;
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    };

    resize();
    renderer.render(scene, camera);

    let tick = 0;
    const animate = () => {
      tick += 0.011;

      cubeA.rotation.x += 0.011;
      cubeA.rotation.y += 0.014;
      cubeA.position.y = Math.sin(tick * 0.8) * 0.09;

      cubeB.rotation.x += 0.009;
      cubeB.rotation.y += 0.01;
      cubeB.position.y = 0.72 + Math.sin(tick * 0.62 + 0.8) * 0.08;

      renderer.render(scene, camera);
      rafId = window.requestAnimationFrame(animate);
    };
    animate();

    const onWindowResize = () => resize();
    if ('ResizeObserver' in window) {
      observer = new ResizeObserver(() => resize());
      observer.observe(stage);
    } else {
      window.addEventListener('resize', onWindowResize);
    }

    const cleanup = () => {
      window.cancelAnimationFrame(rafId);
      if (observer) {
        observer.disconnect();
      } else {
        window.removeEventListener('resize', onWindowResize);
      }

      cubeA.geometry.dispose();
      cubeB.geometry.dispose();
      cubeA.material.dispose();
      cubeB.material.dispose();
      renderer.dispose();
      renderer.domElement.remove();
      delete root.dataset.webglReady;
    };

    root.__webglCleanup = cleanup;
    window.addEventListener('pagehide', cleanup, { once: true });
  };

  const initAll = () => {
    document.querySelectorAll('[data-webgl-cube-demo]').forEach(initDemo);
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAll, { once: true });
  } else {
    initAll();
  }
  document.addEventListener('astro:page-load', initAll);
</script>

<style>
  .webgl-demo {
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
    margin: 20px 0;
    background: color-mix(in srgb, var(--surface) 82%, transparent);
  }

  .webgl-stage {
    width: 100%;
    min-height: 220px;
    border: 1px solid var(--border-soft);
    border-radius: 10px;
    overflow: hidden;
    background:
      radial-gradient(circle at 14% 10%, rgba(94, 169, 255, 0.14), transparent 46%),
      radial-gradient(circle at 82% 18%, rgba(66, 207, 116, 0.12), transparent 40%),
      linear-gradient(180deg, rgba(7, 11, 20, 0.98), rgba(4, 8, 15, 1));
  }

  .webgl-stage canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  .webgl-status {
    margin: 12px 0 0;
    font-size: 0.86rem;
    color: var(--text-muted);
    text-align: center;
  }
</style>
